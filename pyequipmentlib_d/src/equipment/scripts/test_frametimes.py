#!/usr/bin/env python
import csv
import os
import tempfile

import click
import matplotlib.pyplot as plt
import numpy as np
from psychopy.monitors import Monitor, getAllMonitors
from psychopy.visual import TextStim, Window


@click.command()
@click.option(
    "--monitor",
    "-m",
    type=click.Choice(getAllMonitors()),
    help="Monitor ID for rendering frames when no input file is given (see PsychoPY MonitorCenter).",
)
@click.option(
    "-f",
    "--frames",
    default=1000,
    type=int,
    show_default=True,
    help="Number of frames to render for latency testing if no input filename is given",
)
@click.option(
    "-csv",
    "--csv-path",
    type=click.Path(),
    show_default=True,
    help="A path to an input .csv file with frame times as generated by psychopy Window.saveFrameIntevals.",
)
def main_cli(monitor, frames, csv_path):
    target_frame_time = -1
    thresh_frame_time = -1
    # Render frames and save frametimes to csv
    if csv_path is None:
        monitor = Monitor(monitor)
        win = Window(
            checkTiming=True,
            fullscr=True,
            size=monitor.getSizePix(),
            monitor=monitor,
            allowGUI=False,
            waitBlanking=True,
            winType='glfw',
            backendConf=dict(
                refreshHz=250,
                bpc=10,
            )
        )
        fps = 1/win.monitorFramePeriod
        win.recordFrameIntervals = True
        for i in range(frames):
            text = TextStim(win, f"{i+1}/{frames} \n fps: {fps}")
            text.draw()
            win.flip()
        csv_path = os.path.join(tempfile.mkdtemp(), "frametimes.csv")
        win.saveFrameIntervals(csv_path)
        target_frame_time = win.monitorFramePeriod
        thresh_frame_time = win.refreshThreshold
        win.close()

    # Read frametimes from csv
    with open(csv_path, mode="r") as file:
        reader = csv.reader(file, delimiter=",")
        frame_intervals = next(reader)

    # Plot frametimes
    frame_intervals = np.array(frame_intervals).astype(float)
    mean_interval = frame_intervals.mean()
    drop_idc = frame_intervals > thresh_frame_time
    x = np.arange(len(frame_intervals))

    fig, axs = plt.subplots(1, 2, sharey=True, gridspec_kw={"width_ratios": [7, 1]})

    axs[0].plot(x, frame_intervals)
    axs[0].axhline(mean_interval, color="grey", label="Mean frame interval")
    if target_frame_time > 0:
        axs[0].axhline(target_frame_time, color="green", label="Monitor specification")
    if thresh_frame_time > 0:
        axs[0].scatter(
            x[drop_idc], frame_intervals[drop_idc], color="red", marker="+", zorder=2.5
        )
        axs[0].axhline(thresh_frame_time, color="red", label="Drop threshold")

    axs[0].set_yticks(
        [1 / 50, 1 / 60, 1 / 120, 1 / 144, 1/250], ["1/50", "1/60", "1/120", "1/144", "1/250"]
    )
    axs[0].set_xlabel("Frames")
    axs[0].set_ylabel("Frame times (s)")
    axs[0].legend()

    axs[1].boxplot(frame_intervals, sym="+")
    axs[1].axhline(mean_interval, color="grey")
    if target_frame_time > 0:
        axs[1].axhline(target_frame_time, color="green")
    if thresh_frame_time > 0:
        axs[1].scatter(
            np.ones(len(x[drop_idc])),
            frame_intervals[drop_idc],
            color="red",
            marker="+",
            zorder=2.5,
        )
        axs[1].axhline(thresh_frame_time, color="red")

    fig.suptitle(csv_path)
    plt.show()


if __name__ == "__main__":
    main_cli()
